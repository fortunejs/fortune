# Getting Started

Fortune provides generic features (mostly [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) and [serialization](https://en.wikipedia.org/wiki/Serialization)) intended to be used in web applications, or [*skins around databases*](https://www.reddit.com/r/programming/comments/1a2mf7/programming_is_terriblelessons_learned_from_a/c8tjzl5) for the haters. The purpose is to provide data persistence and manipulation given a set of models that conform to [some limitations](https://github.com/fortunejs/fortune/blob/rewrite/lib/index.js#L134-L171). It is intended to be used standalone or composed within Node.js web frameworks (Express, Connect, Koa, etc).

The first thing you'll have to do is install [Node.js](https://nodejs.org/) (if you're on Linux, install `nodejs` from your package manager). You will need [Babel](http://babeljs.io) to run ES6 code:

```
$ npm install -g babel
```

*Note: if the above did not work, you will probably need root permissions, so try running it with `sudo`.*

Then install Fortune from the command-line:

```
$ npm install fortune
```

Then create an empty `index.js` file next to the `node_modules` folder, and start by importing things:

```js
import Fortune from 'fortune'
import http from 'http'
```

Using Fortune with HTTP is optional, but since the built-in serializers provide HTTP functionality in conjunction with the `Fortune.net.http` module, it's easy to get started with it. Create an instance of Fortune, along with a HTTP listener function:

```js
const app = new Fortune()
const listener = Fortune.net.http.bind(app)
```

We don't need to pass any arguments to the `Fortune` constructor, the defaults should work. The `net.http` module is a listener function that accepts a `request` and `response` object that is generated by Node.js. It needs to be [bound](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind) to the application in order to work. The reason why it needs to be bound is that the listener function refers to `this`, which should be a Fortune instance.

The application must have record types to be useful. Let's start with a basic example:

```js
app.defineType('user', {
  username: { type: String },
  key: { type: Buffer },
  salt: { type: Buffer },
  group: { link: 'group', inverse: 'users', isArray: true }
})

app.defineType('group', {
  name: { type: String },
  users: { link: 'user', inverse: 'group', isArray: true }
})
```

This defines a `user` record type that has a relationship to the `group` type. By default, relationships are to-one, unless `isArray` is specified. In this example, there is a many-to-many relationship between a user and a group. The `inverse` field specifies a corresponding field on the linked type, so that any update to either field will affect the other.

Transformations can be defined per record type. For the user type, it would be a good idea to store the password as a cryptographically secure key, and to hide fields when displaying the record. Transform functions accept at least two arguments, the `context` object, and the record. The record for an input transform may be the record to be created or deleted, or an updated record with updates applied.

```js
import crypto from 'crypto'

const { errors } = Fortune
const { methods } = app.dispatcher
const [ iterations, keyLength, saltLength ] =
  [ Math.pow(2, 15), Math.pow(2, 9), Math.pow(2, 6) ]

app.transformInput('user', (context, record) => {
  const { method, type } = context.request
  const { password, id } = record
  let salt, key

  if (method === methods.delete) return null

  if (method === methods.create && !password)
    throw new errors.BadRequestError(`Password must be specified.`)

  // If a password is supplied, there are asynchronous operations involved.
  return password ? new Promise((resolve, reject) =>
    // Generate a new salt.
    crypto.randomBytes(saltLength, (error, buffer) =>
    error ? reject(error) : resolve(buffer)))
  .then(buffer => {
    salt = buffer

    return new Promise((resolve, reject) =>
      // Generate secure password key.
      crypto.pbkdf2(password, salt.toString(),
        iterations, keyLength, (error, buffer) =>
        error ? reject(error) : resolve(buffer)))
  })
  .then(buffer => {
    key = buffer

    if (method === methods.create) {
      record.key = key
      record.salt = salt
      return record
    }

    return app.adapter.update(type, {
      id, replace: { key, salt }
    })
  }) : record
})

app.transformOutput('user', (context, record) => {
  // Hide sensitive fields.
  delete record.salt
  delete record.key

  return record
})
```

Input transform functions are run before anything gets persisted, so it is safe to throw errors. Note that the `password` field on the record is not defined in the record type. Arbitrary fields should be parsed on create/update but not persisted.
