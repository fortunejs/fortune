<!DOCTYPE html><!--

This page is automatically generated. See:
https://github.com/fortunejs/fortune/tree/master/website

--><meta charset="utf-8"><title>Guide</title><link rel="icon" href="../assets/fortune_pig.png"><link rel="stylesheet" href="../assets/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.perfect-scrollbar/0.6.12/css/perfect-scrollbar.min.css"><header><div><a href="../"><img src="../assets/fortune_logo.svg" alt="Fortune.js" class="logo-type"></a><a href="https://github.com/fortunejs/fortune" class="corner">GitHub<span> Repository</span></a></div></header><main><article><h1>Guide</h1><p><em>This guide assumes familiarity with Node.js, JavaScript, and databases, and is intended to show how to use Fortune.js effectively.</em></p><p>Fortune.js is a non-native graph database abstraction layer for Node.js and web browsers. It makes assumptions about the data model in order to build features on top of those assumptions:</p><ul><li><strong>Inverse relationship updates</strong>: when using links in the definition of a record type, Fortune.js will automatically write the other side of the link.</li><li><strong>Referential integrity</strong>: Fortune.js ensures that all links must be valid at the application level.</li><li><strong>Type validation</strong>: fields are guaranteed to belong to a single type.</li><li><strong>Adapter interface</strong>: any database driver that can implement the Adapter abstract base class can work with Fortune.js.</li></ul><p>The only required input of Fortune.js are <em>record types</em>, which are analogous to a <code>struct</code> in C-like languages. Record types guarantee that fields must belong to a single type or that they are links. The valid types are native JavaScript types including <code>Buffer</code> from Node.js, and custom types may extend one of the native types. A link must refer to an ID belonging to a single record type. Both types and links may be defined as arrays or singular values.</p><p>Links in record type fields are just primitive values that correspond to the ID of a record in a collection. What is special about links is that Fortune.js automatically manages both sides of the relationship. Writing a link on a record will cause other records to be written as well.</p><h2 id="motivation">Motivation<a class="anchor" href="#motivation" title="Link to this section “Motivation”">#</a></h2><p>Databases implement disparate sets of features, Fortune.js provides common functionality that may not be implemented by the underlying database. The abstraction layer that Fortune.js provides can be extended to network protocols, as HTTP and WebSocket can be exposed using the same application code, using any serialization format.</p><p>There is a misconception that database abstractions are for porting application code to use another database, which rarely is the case. However, this is particularly useful for writing applications that can run anywhere, such as on a server or a client where different databases may be a necessity.</p><h2 id="type-definition">Type Definition<a class="anchor" href="#type-definition" title="Link to this section “Type Definition”">#</a></h2><p>Here is a basic example of record type definitions, which may model a micro-blogging service:</p><pre><code class="language-js">const fortune = require(&#39;fortune&#39;)

const recordTypes = {
  post: {
    text: String,
    createdAt: Date,
    replies: [ Array(&#39;post&#39;), &#39;parent&#39; ],
    parent: [ &#39;post&#39;, &#39;replies&#39; ],
    author: [ &#39;user&#39;, &#39;posts&#39; ]
  },
  user: {
    name: String,
    password: Buffer,
    salt: Buffer,
    posts: [ Array(&#39;post&#39;), &#39;author&#39; ],
    following: [ Array(&#39;user&#39;), &#39;followers&#39; ],
    followers: [ Array(&#39;user&#39;), &#39;following&#39; ]
  }
}

const store = fortune(recordTypes)
</code></pre><p>This is already very close to a working web application. The rest of this guide will focus on all of the parts which are relevant for building this hypothetical application.</p><h2 id="adapter-interface">Adapter Interface<a class="anchor" href="#adapter-interface" title="Link to this section “Adapter Interface”">#</a></h2><p>By default, Fortune.js uses an in-memory database. While this is fine for development purposes, it will not scale beyond a single thread nor will it persist data. What Fortune.js provides is an abstract base class for dealing with the database called the <code>Adapter</code>. To use an adapter, it must be specified. For example, using the Postgres adapter:</p><pre><code class="language-js">const pgAdapter = require(&#39;fortune-postgres&#39;)

const adapter = [ pgAdapter, {
  // In this example, the Postgres adapter requires the connection URL.
  url: &#39;postgres://postgres@localhost:5432/app_db&#39;
} ]

const store = fortune(recordTypes, { adapter })
</code></pre><p>The adapter must implement the create, find, update, and delete methods. The find method specifies basic querying options, such as sorting, matching, ranges, existence, sparse fields, limit and offset. An adapter may optionally implement more adapter-specific queries, as well as transactions. In this case, the Postgres adapter implements transactions, so that each request to Fortune.js is atomic.</p><h2 id="internationalization">Internationalization<a class="anchor" href="#internationalization" title="Link to this section “Internationalization”">#</a></h2><p>In most real world applications, data must be validated for errors. Fortune.js exposes its own error classes and the <code>message</code> function to help translate errors to status codes and localized text. All of the error messages that Fortune.js uses internally and exposes to clients may be localized, and custom error messages may be specified like so:</p><pre><code class="language-js">const { message } = fortune

// Add application error messages in English (default language).
// More languages can be defined as keys on the `message` function.
Object.assign(message.en, {
  &#39;InvalidAuthorization&#39;: &#39;The given user and/or password is invalid.&#39;,
  &#39;InvalidPermission&#39;: &#39;You do not have permission to do that.&#39;,
  &#39;MissingField&#39;: &#39;The required field &quot;{field}&quot; is missing.&#39;
})
</code></pre><p>It is entirely optional to use this feature, but it is provided since <code>Intl</code> is not defined in ES5. There is a <a href="http://wiki.ecmascript.org/doku.php?id=globalization:messageformatting">specification for message formatting</a> which should be preferred.</p><h2 id="input-and-output-hooks">Input and Output Hooks<a class="anchor" href="#input-and-output-hooks" title="Link to this section “Input and Output Hooks”">#</a></h2><p>Input and output hooks are user-defined functions which are run before writing a record, and after reading a record. They exist merely for convenience, one could also override the <code>request</code> method to implement the same functionality. These hooks are intended to isolate business logic, and any errors thrown here may be mapped to status codes. They may be specified like so:</p><pre><code class="language-js">const hooks = {
  user: [ userInput, userOutput ],
  post: [ postInput ]
}

const store = fortune(recordTypes, { hooks })
</code></pre><p>All of the arguments for the I/O hooks may be mutated. Any custom errors thrown will be displayed to client, while operational errors will be hidden (native errors such as <code>Error</code>).</p><p>For example, dealing with input for the <code>user</code> record type, a variety of authorization cases need to be handled. When creating a user, the name and password fields must be checked and the password must be encrypted, while updating and deleting require an authorization check.</p><pre><code class="language-js">const { methods, errors: { BadRequestError } } = fortune

function userInput (context, record, update) {
  const { request: { method, meta: { language } } } = context

  switch (method) {
  case methods.create:
    // Check for required fields.
    for (const field of [ &#39;name&#39;, &#39;password&#39; ])
      if ((!field in record)) throw new BadRequestError(
        message(&#39;MissingField&#39;, language, { field }))

    const { name, password } = record
    return Object.assign({ name }, makePassword(password))

  case methods.update:
    return validateUser(context, update.id).then(() =&gt; {
      if (update.replace) {
        // Only allow updates to name and password.
        const { replace: { name, password } } = update
        update.replace = { name }
        if (password) Object.assign(update.replace, makePassword(password))
      }

      // Only allow push/pull updates to follow and unfollow.
      if (update.push) update.push = { following: update.push.following }
      else if (update.pull) update.pull = { following: update.pull.following }
    })

  case methods.delete:
    return validateUser(context, record.id)
  }
}
</code></pre><p>The password hashing function is an implementation detail. In this example, a hash function is used for the sake of simplicity, though a key derivation function or stronger should be used in real applications.</p><pre><code class="language-js">const hashAlgorithm = &#39;SHA256&#39;

function makePassword (string) {
  const salt = crypto.randomBytes(32)
  const password = crypto.createHash(hashAlgorithm)
    .update(salt).update(&#39;&#39; + string).digest()

  return { salt, password }
}
</code></pre><p>The <code>validateUser</code> function is an implementation detail which may be shared across other hooks. For stateless protocols such as HTTP, the request parameters should contain all of the information necessary to make the request, including authorization credentials.</p><pre><code class="language-js">const crypto = require(&#39;crypto&#39;)

const { errors: { UnauthorizedError, ForbiddenError } } = fortune

function validateUser (context, userId) {
  const {
    request: { meta: { headers: { authorization }, language } },
    response: { meta }
  } = context

  // Parse HTTP Basic Access Authentication.
  const [ userId, password ] = atob(authorization.split(&#39; &#39;)[1]).split(&#39;:&#39;)

  if (!userId || !password) {
    if (!meta.headers) meta.headers = {}
    meta.headers[&#39;WWW-Authenticate&#39;] = &#39;Basic realm=&quot;App name&quot;&#39;
    throw new UnauthorizedError(message(&#39;InvalidAuthorization&#39;, language))
  }

  const options = { fields: { password: true, salt: true } }

  return store.adapter.find(&#39;user&#39;, [ userId ], options).then(result =&gt; {
    const [ user ] = result
    const error = new ForbiddenError(message(&#39;InvalidPermission&#39;, language))

    if (!user || (userId &amp;&amp; userId !== user.id)) throw error

    const hash = crypto.createHash(hashAlgorithm)
      .update(user.salt).update(password).digest()

    // Prefer a constant-time equality check, this is not secure.
    if (!hash.equals(user.password)) throw error

    return user
  })
}
</code></pre><p>When reading a user, the password and salt must not be exposed. This can be done in the output hook:</p><pre><code class="language-js">function userOutput (context, record) {
  delete record.password
  delete record.salt
}
</code></pre><p>The <code>post</code> type only needs to check for validity and whitelist fields that may be written.</p><pre><code class="language-js">function postInput (context, record, update) {
  const { request: { method, meta: { language } } } = context

  switch (method) {
  case methods.create:
    const { text, parent } = record
    return validateUser(context).then(user =&gt; ({
      text, parent, createdAt: new Date(), author: user.id
    }))

  case methods.update:
    throw new ForbiddenError(message(&#39;InvalidPermissions&#39;, language))

  case methods.delete:
    return validateUser(context, record.author)
  }
}
</code></pre><h2 id="networking">Networking<a class="anchor" href="#networking" title="Link to this section “Networking”">#</a></h2><p>All networking is external to Fortune.js. It makes no assumption that there is even a network at all. This makes it feasible to write applications which are decoupled from the network protocol.</p><p>There is a <code>fortune-http</code> package which maps requests and responses from the listener function arguments in Node.js to Fortune.js. What it does is implement relevant parts of the HTTP protocol such as content negotiation, status codes, caching and encoding. In the example above, error classes are used, and each error class maps to a status code.</p><p>A few basic serializers are included. To use it:</p><pre><code class="language-js">const http = require(&#39;http&#39;)
const fortuneHTTP = require(&#39;fortune-http&#39;)

const listener = fortuneHTTP(store, {
  // The order specifies priority of media type negotiation.
  serializers: [
    fortuneHTTP.JsonSerializer,
    fortuneHTTP.HtmlSerializer,
    fortuneHTTP.FormDataSerializer,
    fortuneHTTP.FormUrlEncodedSerializer
  ]
})

const server = http.createServer((request, response) =&gt;
  listener(request, response)
  .catch(error =&gt; { /* error logging */ }))

server.listen(1337)
</code></pre><p>There is also a <code>fortune-ws</code> package, which may be useful for real-time updates. It implements a wire protocol that uses MessagePack as a serialization format.</p><p>Suppose that new posts from users who are followed should be sent. The client must initiate a state change containing users to follow, so that the server knows which posts to send.</p><pre><code class="language-js">const fortuneWS = require(&#39;fortune-ws&#39;)

const options = { port: 1337 }
const server = fortuneWS(store, (state, changes) =&gt; {
  // Whitelist state changes.
  if (!changes) return { users: Array.isArray(state.users) ? state.users : [] }

  // Only send new posts from users that are being followed.
  if (changes[methods.create] &amp;&amp; changes[methods.create].post) {
    const post = state.users ? changes[methods.create].post
      .filter(post =&gt; ~state.users.indexOf(post.author)) : []

    if (post.length) return { [methods.create]: { post } }
  }
}, options)
</code></pre><p>A web client can listen for changes:</p><pre><code class="language-js">const client = new WebSocket(...)
const users = [ ... ]

fortuneWS.request(client, null, { users })
.then(() =&gt; fortuneWS.sync(client, store))
</code></pre><h2 id="philosophy">Philosophy<a class="anchor" href="#philosophy" title="Link to this section “Philosophy”">#</a></h2><p>Most web applications are like skins around databases. Fortune.js provides an abstraction around core functionality of web applications. It is designed as a library which adds useful features on top of databases.</p><p>It avoids the Object-Relational or Object-Document Mapping problem by not dealing with <em>objects</em> in the Object-Oriented Programming sense. Records in Fortune.js do not inherit any classes and are just plain data structures.</p><p>It targets Node.js and web browsers with the same codebase, since the same concepts apply in both environments.</p><footer>&copy; 2024 &nbsp;&mdash;&nbsp; <a href="https://raw.githubusercontent.com/fortunejs/fortune/master/LICENSE">MIT License</a></footer></article><nav><div><h4>Docs <span class="version">(v5.5.19)</span></h4><ul><li><a href="../"><span>Readme</span></a></li><li><a href="../guide/"><span>Guide</span></a></li><li><a href="../api/"><span>API Reference</span></a></li><li><a href="../plugins/"><span>Plugins</span></a></li><li><a href="../concepts/"><span>Concepts</span></a></li><li><a href="../changelog/"><span>Changelog</span></a></li></ul><h4>Fortune</h4><ul><li><a href="../api/#fortune"><span>Fortune</span></a></li><li><a href="../api/#fortune-constructor"><span>constructor</span></a></li><li><a href="../api/#fortune-request"><span>request</span></a></li><li><a href="../api/#fortune-find"><span>find</span></a></li><li><a href="../api/#fortune-create"><span>create</span></a></li><li><a href="../api/#fortune-update"><span>update</span></a></li><li><a href="../api/#fortune-delete"><span>delete</span></a></li><li><a href="../api/#fortune-connect"><span>connect</span></a></li><li><a href="../api/#fortune-disconnect"><span>disconnect</span></a></li></ul><h4>Adapter</h4><ul><li><a href="../api/#adapter"><span>Adapter</span></a></li><li><a href="../api/#adapter-constructor"><span>constructor</span></a></li><li><a href="../api/#adapter-connect"><span>connect</span></a></li><li><a href="../api/#adapter-disconnect"><span>disconnect</span></a></li><li><a href="../api/#adapter-create"><span>create</span></a></li><li><a href="../api/#adapter-find"><span>find</span></a></li><li><a href="../api/#adapter-update"><span>update</span></a></li><li><a href="../api/#adapter-delete"><span>delete</span></a></li><li><a href="../api/#adapter-begintransaction"><span>beginTransaction</span></a></li><li><a href="../api/#adapter-endtransaction"><span>endTransaction</span></a></li><li><a href="../api/#adapter-applyoperators"><span>applyOperators</span></a></li></ul><h4>HTTP Server</h4><ul><li><a href="../api/#fortunehttp-createlistener"><span>createListener</span></a></li></ul><h4>HTTP Serializer</h4><ul><li><a href="../api/#httpserializer"><span>HttpSerializer</span></a></li><li><a href="../api/#httpserializer-constructor"><span>constructor</span></a></li><li><a href="../api/#httpserializer-processrequest"><span>processRequest</span></a></li><li><a href="../api/#httpserializer-processresponse"><span>processResponse</span></a></li><li><a href="../api/#httpserializer-parsepayload"><span>parsePayload</span></a></li><li><a href="../api/#httpserializer-mediatype"><span>mediaType</span></a></li></ul><h4>WebSocket</h4><ul><li><a href="../api/#fortunews-createserver"><span>createServer</span></a></li><li><a href="../api/#fortunews-request"><span>request</span></a></li><li><a href="../api/#fortunews-sync"><span>sync</span></a></li></ul><hr></div></nav></main><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.perfect-scrollbar/0.6.12/js/perfect-scrollbar.min.js"></script><script>Ps.initialize(document.querySelector('nav > div'))</script>